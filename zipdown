#!/usr/bin/perl -T
# -T == taint mode: https://perldoc.perl.org/perlsec#Laundering-and-Detecting-Tainted-Data

use strict;
use warnings;
use Time::HiRes qw( time );
use English;
use Encode;
use File::Find;
use File::Temp qw( tempdir );
use IO::Compress::Zip qw(zip $ZipError :constants);
# ^^^-end core Perl modules, vvv-begin non-core modules:
use CGI;  # from `apt-get install libcgi-pm-perl`
use CGI::Carp qw(fatalsToBrowser warningsToBrowser set_message);  # from `apt-get install libcgi-pm-perl`

use FindBin qw( $RealBin );
my $untainted_bin;  # Taint Mode gyrations courtesy of https://www.perlmonks.org/?node_id=11120715 (last answer)
BEGIN { ($untainted_bin) = $RealBin =~ /(.+)/; }
use lib "$untainted_bin";
use Site;

my ($tm_start,$et_srch,$et_find) = (time(), 0, 0);

sub pr_et_us { return sprintf("%.6f", $_[0]); }

handler_zipdownload( CGI->new );

sub handler_zipdownload { my ($qy) = @_;
   exists $qy->Vars->{zipdowndirnm} or die "missing param 'zipdowndirnm'\n";
   my $p = '<br>';
   my ($weblink) = $qy->Vars->{zipdowndirnm} =~ m=^((?:(?!\.\./).)*)$=; # print "weblink=$weblink$p\n";   # untaint
   my @dbglog;  # since if we output (html headers and) any text, we'll be unable to download the target file, we collect log text and output on failure
   my $carp_msg_handler = sub {
      my $msg = shift;
      local $LIST_SEPARATOR = "\n";
      print "$p@dbglog\n";
      print "${p}${p}Error: $msg" if $msg;
      };
   set_message( $carp_msg_handler );
   my $dl = sub { push @dbglog, join( ' ', @_ ) if @_; };
   $dl->( $qy->header );
   $dl->( $qy->start_html(
         -title=>"zipdownload $weblink",
         -base=>'true', -target=>'_blank',  # links on this page will open in new client (browser) tab/window.
         )
        );
   for my $hr ( @Site::treelocns ) {  # linear search to find treelocn containing $weblink so we can xlat to fs locn
      my ($fsroot,$webroot,$findtype) = @{$hr}{qw(fsroot webroot ft)}; # print "\nfsroot=$fsroot\n";
      next unless $weblink =~ m=^\Q$webroot=;
      $dl->( $qy->h3("zipdownload $weblink"), "\n" );
      $dl->( "hit on webroot=$webroot" );
      $dl->( " but findtype=$findtype != 'd'" ) unless $findtype eq 'd';
      $dl->( "$p\n" );
      my $fsNmAbs = $weblink =~ s=^\Q$webroot=$fsroot=r;
      $dl->( "fsNmAbs=$fsNmAbs" );
      $dl->( " but it isn't a directory!" ) unless -d $fsNmAbs;
      $dl->( "$p\n" );

      my $td = tempdir( DIR => Site::CACHEDIR, CLEANUP => 1 );
      $dl->( "tempdir=$td$p\n" );

      # copied from my repo=shell/m3u
      my ($reToZip,$reM3u) =
      do {
         my @playableExts   = qw( mp3 mp4 mpg m4a m4b wmv flac f4v flv );
         my @playAssistExts = qw( srt vtt );
         my $extRE = sub {
            my $rv = '\.(?i)(?:' . join('|', @_) . ')$'; # $dl->( "\npat=$rv\n" );
            return qr($rv);
            };
         ( $extRE->( @playableExts, @playAssistExts )
         , $extRE->( @playableExts )
         )
         };
      my $rePathLeaf = qr([^/]+$);
      my ($zipfnm) = $fsNmAbs =~ m!($rePathLeaf)!;  $zipfnm .= '.zip';
      my $reFsNmAbs = '^' . quotemeta($fsNmAbs =~ s!$rePathLeaf!!r);  $dl->( "reFsNmAbs=$reFsNmAbs$p\n" );
      my (@srcfnms,@m3ufnms,%eachdir);
      find(
         { wanted => sub {
            return unless -f $_;             # $dl->( "F0=$_\n" );                 # sanspath i.e. leaf name: might be a dir; ignore these
            ++$eachdir{$File::Find::dir};    # $dl->( "F1=$File::Find::name\n" );  # == "$File::Find::dir/$_": NB !!! WE ARE CD'D INTO $File::Find::dir !!!
            push @srcfnms, $File::Find::name if $_ =~ $reToZip;
            push @m3ufnms, $File::Find::name if $_ =~ $reM3u;
            },
         , untaint => 1  # https://perldoc.perl.org/File::Find#%25options
         , untaint_pattern => qr|^([-+@\w\s./]+)$|  # update (for other filename chars) if 'Insecure dependency in chdir while running with -T switch' is encountered
         }, $fsNmAbs
         );  # temporarily CD's into $fsNmAbs dir tree dirs;

      @srcfnms = sort @srcfnms;  # prettify for $dl; no functional need
      $dl->( "${p}srcfnms:\n" );
      { # we create zip file w/Z_NO_COMPRESSION so sum of input filesizes is an accurate predictor of zip file size
      my ($maxMB, $sumMB) = (1500, 0);
      for( @srcfnms ) {
         my $fMB = int((stat $_)[7] / (1024*1024));
         $dl->( $p, sprintf( '%3dMB ', $fMB ), $_, "\n" );
         $sumMB += $fMB;
         }
      die "total playable file size ${sumMB}MB > ${maxMB}MB limit\n" if $sumMB > $maxMB;
      $dl->( "${p}total playable file size ${sumMB}MB <= ${maxMB}MB limit\n" );
      }

      # prior to zipping generate a m3u file in eachdir _if_ it or any of its child dirs contain @m3ufnms

      # since this process does NOT have write access to $fsNmAbs, we will write
      # any generated m3u files to a tempdir, and use zip-time archive filename
      # mapping (FilterName) to include these files in the zip file with the
      # intended user-visible names
      my $tempfIx = 0;
      my %tempFnmMap;
      sub wr_array { my ($ofnm,$aref) = @_;
         my $tmpFnm = sprintf( "$td/wr_array_%03d", $tempfIx++ );
         $dl->( "${p}writing $ofnm ($tmpFnm)\n" );
         $tempFnmMap{$tmpFnm} = $ofnm;
         $ofnm              = $tmpFnm;
         open my $ofh, ">", $ofnm or die "can't open $ofnm for writing: $!\n";
         local $LIST_SEPARATOR = "\n";
         print $ofh "@$aref";
         push @srcfnms, $ofnm;
         }
      sub write_m3u { my ($destdir,$aref) = @_; # $dl->( "F0=$destdir\n" );
         my @results;
         my $ddre = quotemeta($destdir);
         for my $fnm ( @$aref ) {
            if( my ($fnm_rel) = $fnm =~ m|^$ddre[\\/](.+)$| ) { # $dl->( "F1=$fnm_rel\n" );
               $fnm_rel =~ s!/+!\\!g;  # $dl->( "F2=$fnm_rel\n" );
               $fnm_rel =~ s!\\+!\\!g; # $dl->( "F3=$fnm_rel\n" );
               $fnm_rel =~ s!^\.\\!!;  # $dl->( "F4=$fnm_rel\n" );
               push @results, $fnm_rel;
               }
            }
         if( @results > 1 ) {
            @results = sort @results;
            wr_array( "$destdir/00.m3u", \@results ) ;  # no playlist file needed for single playable file
            }
         }

      $dl->( "${p}\n" );
      write_m3u( $_, \@m3ufnms ) for ( sort keys %eachdir );
      @srcfnms = sort @srcfnms;  # merge m3u additions

      $dl->( "${p}${p}srcfnms:\n" ); $dl->( $p, $_, "\n" ) for @srcfnms;
      {
      # A VERY annoying property of map BLOCK that I forgot(?): modifying $_ in
      # BLOCK modifies the SOURCE array element that $_ is an alias for (so in
      # this case, acting on $_ directly ($_ = $tempFnmMap{$_} // $_;) causes
      # @srcfnms to be modified).
      #
      # Following are 3 ways to workaround:
      my @mappedSrcFnms = map {                  ($tempFnmMap{$_} // $_)    =~ s!$reFsNmAbs!!r } @srcfnms;  # perform return-subst on a rvalue (expression)
    # my @mappedSrcFnms = map { my $f           = $tempFnmMap{$_} // $_; $f =~ s!$reFsNmAbs!!r } @srcfnms;  # use new var containing copy of $_ value in lieu of $_
    # my @mappedSrcFnms = map { local $_=$_; $_ = $tempFnmMap{$_} // $_;       s!$reFsNmAbs!!r } @srcfnms;  # local-ize $_ https://stackoverflow.com/a/63167
      $dl->( "${p}${p}mappedSrcFnms:\n" ); $dl->( $p, $_, "\n" ) for @mappedSrcFnms;
      }

      $dl->( "${p}dope done\n" );
      $dl->( $qy->ol( [ "Toverall: ".pr_et_us( time() - $tm_start ) ] ), "\n" );

      my $absZipfnm = "$td/zipfile";  # name of this file is independent of downloaded filename

      # Create zip file by writing it to $absZipfnm, then immediately cat the
      # entire file to STDOUT, then delete it.
      #
      # Drawbacks: download doesn't begin until zip file creation is complete,
      # and these files consume SSD partition space (transiently).
      #
      # Mitigations, performance: we write the zip file to SSD (so pretty fast),
      # and we create the zip file using Z_NO_COMPRESSION for fastest creation
      # and client decompression speed (the theory being that mp3 files are
      # already optimally compressed, and anyway our purpose in offering a zip
      # format download is not compression, but rather to package a structured
      # fileset into a single file with integrity checking into a single
      # downloadable file).
      #
      # Mitigations, temp disk consumption: $absZipfnm (along with all other
      # files in $td) is auto-deleted when this process exits (the download
      # having completed by then), preventing runaway temp disk consumption.
      #
      # Benefits: #1, it works!  That aside: having the complete zip file in
      # hand prior to download allows us to supply a content_length response
      # header so the http client can see a known-size download progressing.

      # A theoretical alternative approach would be to stream the zip file bytes
      # onto the wire as they're being generated.  Benefits: possibly shorter
      # time before download commences, no concerns about free disk space
      # availability, time consuming temp file disk writes, or temp file cleanup.
      # But since most albums are no more than a few hundred MB, it doesn't take
      # much time to write that many bytes, tempfile auto-cleanup is a solved
      # problem, and time-to-first zipfile byte being downloaded is often gated
      # by the delay required to spinup the HDD containing the mp3 files, a delay
      # which affects both approaches similarly (and dwarfs the time required to
      # write a few hundred MB to SSD).  And of course we can't supply
      # content_length in the response header since it isn't known yet.  In
      # https://www.perlmonks.org/?node_id=929668 the author of IO::Compress::Zip
      # gives streaming examples which depend on http 1.1 response header
      # `Transfer-Encoding: chunked`, BUT! these streaming examples rely on
      # UNDOCUMENTED feature FilterContainer nee FilterEnvelope!!!  I tried the
      # example FilterContainer sub verbatim, and while it seemed to generate
      # correct chunk headers, these were not honored downstream, instead the
      # chunk headers were incorporated into the downloaded zip file, corrupting
      # it.  Aside: this experiment did not show the streaming approach to be any
      # faster than the static tempfile approach.

      # Updt 20220707: per
      # https://redmine.lighttpd.net/boards/3/topics/6884 and
      # https://trac.nginx.org/nginx/ticket/1292
      # HTTP 1.1 response header `Transfer-Encoding: chunked` IS NOT SUPPORTED
      # by CGI or FastCGI protocols and thus should not be returned by a CGI
      # process.  Therefore I am removing all code related to 'downloadChunked'.

      my $filterNamer = sub { # this could be (and was) far more terse, but these comments might save future pain...
         # https://perldoc.perl.org/IO::Compress::Zip#File-Naming-Options
         # On entry to the sub the $_ variable will contain the name to be
         # filtered.  If no filename is available $_ will contain an empty
         # string.  The value of $_ when the sub returns will be used as the
         # archive member name.
         $_ = $tempFnmMap{$_} // $_;  # explicitly modify $_
         s!$reFsNmAbs!!;              # implicitly modify $_  NB: syntax differs slightly from map BLOCK used to gen @mappedSrcFnms
         # NB: next line does NOTHING, but doesn't fail either; apparently this closure/sub when called does not have access to $dl?
         # $dl->( "  FilterName: $_" );
         };
      my $zipFail = sub {
         $dl->( "${p}zip done: \n" );
         $dl->( $qy->ol( [ "Toverall: ".pr_et_us( time() - $tm_start ) ] ), "\n" );
         $dl->( $qy->end_html );
         die "zip failed: $ZipError\n";
         };

      zip \@srcfnms => $absZipfnm
         , Level => Z_NO_COMPRESSION
         , Minimal => 1
         , FilterName => $filterNamer
         or $zipFail->();

      # ok, $absZipfnm was created: send it to the client!
      print $qy->header( -type=>'application/zip', -attachment=>$zipfnm, -content_length=>(stat $absZipfnm)[7] );
      open my $ifh, "<", $absZipfnm or die "can't open $absZipfnm for reading: $!\n";
      binmode $ifh;
      binmode STDOUT;
      my $bufsize = 4*1024*1024;
      local $INPUT_RECORD_SEPARATOR = \$bufsize;
      local $OUTPUT_AUTOFLUSH = 1;
      print $_ while( <$ifh> );
      # my $locn = "$weblink/$fn" =~ s{([\s])}{sprintf("%%%02X",ord($1))}egr;  # poor man's urlencode (for '\s' only FTTB)

      last;
      }
   exit 0;
   }  # unimpl
