#!/usr/bin/perl -T
use strict;
use warnings;

$ENV{PATH} = '/bin:/usr/bin';  # to allow running under 'taint mode' (-T in shebang)

# testing cmdlines using http://perldoc.perl.org/CGI.html#DEBUGGING
# time ./search-files search_scope=b search_keys='nginx EPUB'

my @treelocns = (  # unfortunately necessary hardcoding of app filesys/webapp mappings
   { isa => 'b', fsroot=>q(/mnt/smb/pri/data/public/ebooks), webroot=> "/files/ebooks", fo=>q( -type f) },
   { isa => 'm', fsroot=>q(/mnt/smb/pri/data/public/MP3)   , webroot=> "/files/MP3"   , fo=>q( -type d) },
   );

my $maxCopyrightYr = do {
   my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime();
   $year = $year+1900;  # std xlation
   $year + 1;  # (c)Y+1 books appear late in year Y
   };

sub gen_re_match_all_anyorder {
   my @reraw;
   for (@_) {  # construct regex matching lines containing, in any order, ALL of @_
      my $qm = quotemeta( $_ );            #  match fragment
      $qm = qq(\\b$qm\\b) if m=[A-Z0-9]+=; # all caps? match word
      push @reraw, qq[(?=.*$qm)]; # https://stackoverflow.com/questions/4389644/regex-to-match-string-containing-two-names-in-any-order
      }
   my $rv = '^(?i)' . join('',@reraw) . '.*$'; # print "\npat=$rv\n";
   return $rv;
   }

my (%dated_rslts,%extra,$num_cands,$num_matches); # return values from search_files() in these global vars  :-(
sub search_files { my ($isamatch,$pat) = @_;
   for my $href ( @treelocns ) {
      next unless $href->{isa} =~ m=$isamatch=;
      my $fsroot  = $href->{fsroot};  # print "\nfsroot=$fsroot\n";
      my $webroot = $href->{webroot};
      my $findopts = $href->{fo};
      open( my $ifh, "cd $fsroot && find . $findopts|" ) || die "Can't open `find $fsroot $findopts`: $!";
      while ( my $line = <$ifh> ) {
         ++$num_cands;
         chomp $line;
         my ($fnm) = $line =~ m=([^/]+)$=; # print "$fnm\n";
         my $tgt = ".$fnm.";
         if( $tgt =~ m=$pat= ) { # print "$tgt\n" ;
            ++$num_matches;
            my $yr = do {
               my @yr4s = $tgt =~ m=\b(\d{4})(?:\b|[_])=g; # normally, (c) year is given as yyyy
               my @more = $tgt =~ m=\b(\d{4})\d{2}(?:\b|[_])=g; push( @yr4s, @more ); # but rarely I give yyyymm
                  @more = $tgt =~ m=\b(\d{4})\d{4}(?:\b|[_])=g; push( @yr4s, @more ); # and rarely I give yyyymmdd
               my $rv = '';
               if( @yr4s ) {
                  my $max = 0;
                  $max = ($_<=$maxCopyrightYr && $_>$max) ? $_ : $max foreach @yr4s;  # print $max,"\n";
                  $rv = $max if $max > 0;
                  }
               $rv;
               };
            my $ofnm = "$fsroot/$line"; $ofnm =~ s=/\./=/=; # print "$ofnm\n" ;
            my $link; ($link = $ofnm) =~ s=^$fsroot=$webroot=; # print "link=$link\n";
            $extra{$link} = [ $ofnm, $fnm ];  # storing aref is superfluous for now, but may be needed (for e.g. filesize)
            push @{$dated_rslts{$yr}}, $link;
            }
         }
      }
   }

use CGI;
my $qy = CGI->new;
{
my $isamatch    = "[".      ($qy->Vars->{search_scope} // 'b') ."]"; # default to Book search
my @search_keys = split(' ',($qy->Vars->{search_keys } // '' )    );
my $pat = gen_re_match_all_anyorder( @search_keys );
search_files( $isamatch, $pat );
}
print $qy->header;
print $qy->start_html(
      -title=>'Search Result',
      -base=>'true', -target=>'_blank',  # links on this page will open in new client (browser) tab/window.
      );
# print $qy->Dump();
print $qy->h3("Found",($num_matches||"no"),"matches among",$num_cands,"candidates"), "\n";
for my $yr (reverse sort keys %dated_rslts) { # print "$yr:\n";
   print $qy->h3("&copy;".($yr || "<i>unknown</i>")), "\n";
   my @lis;
   for my $link (sort @{$dated_rslts{$yr}}) {
      my $aref = $extra{$link};
      my $fnm = @${aref}[1];
      push @lis, $qy->li($qy->a({href=>$link},$fnm)),"\n";
      }
   print $qy->ol( @lis ), "\n";
   }
print $qy->end_html;
exit 0;
