#!/usr/bin/perl -T
use strict;
use warnings;

$ENV{PATH} = '/bin:/usr/bin';  # to allow running under 'taint mode' (-T in shebang)

# testing cmdlines using http://perldoc.perl.org/CGI.html#DEBUGGING
# time ./search-files search_scope=b search_keys='nginx EPUB'

my $showRegex = 0;

my @treelocns = (  # unfortunately necessary hardcoding of app filesys/webapp mappings
   { isa => 'b', fsroot=>q(/mnt/smb/pri/data/public/ebooks), webroot=> "/files/ebooks", fo=>q( -type f) },
   { isa => 'm', fsroot=>q(/mnt/smb/pri/data/public/MP3)   , webroot=> "/files/MP3"   , fo=>q( -type d) },
   );

my $maxCopyrightYr = do {
   my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime();
   $year = $year+1900;  # std xlation
   $year + 1;  # (c)Y+1 books appear late in year Y
   };

my %tok_remap = ( and => '(?:N|AND)', 'c#' => 'CSHARP', 'f#' => 'FSHARP' );

my ($bound_re_before,$bound_re_after) = ( '(?:^|[\W_])', '(?:$|[\W_])' ); # can't use \b because $qm may not consist of word chars only
my $bound_re = '(?:\b|[_])';
sub gen_re_match_all_anyorder {
   my @reraw;
   for (@_) {  # construct regex matching lines containing, in any order, ALL of @_
      my $qm = quotemeta( $_ );            #  match fragment
      $qm = $tok_remap{lc $qm} if exists $tok_remap{lc $qm};
      $qm = "$bound_re_before$qm$bound_re_after" if ($qm =~ m=[A-Z]=) && ! ($qm =~ m=[a-z]=); # all caps? match word
      push @reraw, "(?=.*$qm)"; # https://stackoverflow.com/questions/4389644/regex-to-match-string-containing-two-names-in-any-order
      }
   my $rv = '^(?i)' . join('',@reraw) . '.*$'; # print "\npat=$rv\n";
   return $rv;
   }

my (%dated_rslts,%extra,$num_cands,$num_matches); # return values from search_files() in these global vars  :-(
sub search_files { my ($isamatch,$pat) = @_;
   for my $hr ( @treelocns ) {
      next unless $hr->{isa} =~ m=$isamatch=;
      my ($fsroot,$webroot,$findopts) = @{$hr}{qw(fsroot webroot fo)}; # print "\nfsroot=$fsroot\n";
      open( my $ifh, "cd $fsroot && find . $findopts|" ) || die "Can't open `find $fsroot $findopts`: $!";
      while ( my $line = <$ifh> ) {
         ++$num_cands;
         chomp $line;
         my ($fnm) = $line =~ m=([^/]+)$=; # print "$fnm\n";
         my $tgt = ".$fnm.";
         if( $tgt =~ m=$pat= ) { # print "$tgt\n" ;
            ++$num_matches;
            my ($base,$type) = $fnm =~ m=(.+?)((?:.[Cc]ode|.medtype|_cropped)?\.[^\.]+)$=; # print "B=$base,T=$type\n";
            my $yr = do {
               my @yr4s = $tgt =~ m=$bound_re(\d{4})$bound_re=g; # normally, (c) year is given as yyyy
               my @more = $tgt =~ m=$bound_re(\d{4})\d{2}$bound_re=g; push( @yr4s, @more ); # but rarely I give yyyymm
                  @more = $tgt =~ m=$bound_re(\d{4})\d{4}$bound_re=g; push( @yr4s, @more ); # and rarely I give yyyymmdd
               my $rv = '';
               if( @yr4s ) {
                  my $max = 0;
                  $max = ($_<=$maxCopyrightYr && $_>$max) ? $_ : $max foreach @yr4s;  # print $max,"\n";
                  $rv = $max if $max > 0;
                  }
               $rv;
               };
            my $ofnm = "$fsroot/$line"; $ofnm =~ s=/\./=/=; # print "$ofnm\n" ;
            my $link; ($link = $ofnm) =~ s=^$fsroot=$webroot=; # print "link=$link\n";
            my $link_wo_type = substr( $link, 0, - length $type ); # print "key=",$link_wo_type,"\n";
            push @{$dated_rslts{$yr}}, $link_wo_type if !exists $extra{$link_wo_type};
            push @{$extra{$link_wo_type}}, $type;
            }
         }
      }
   }
#
# As noted in README.md
#    * suffix variants: `2005.ext` might morph to either
#        * `2005.medtype.ext` generated by [Calibre](https://calibre-ebook.com/ ) when creating PDF from non-PDF, or
#        * `2005_cropped.ext` generated by [briss2](https://github.com/fwmechanic/briss2 ) when cropping a PDF.
# the vast majority of the time, a user will want to download the (cropped) pdf
# version of the ebook.  Since there are potentially many variants (formats and
# croppings) of the SAME book (in INCREASING order of preference:
#    * book.(chm|djvu|azw3|mobi|epub)
#    * book.azw3
#    * book.mobi
#    * book.epub
#    * book.pdf
#    * book_cropped.pdf  (locally generated from book.pdf)
#    * book.medtype.pdf  (locally generated from book.(chm|azw3|mobi|epub))
# ) it would be helpful for these to collapse into a single line containing
# multiple links, with the best version ( being left-most (and the longest
# link).
#
# What I think this means is I want to determine the basename (book) and find
# all files having the same basename and compress them as above.
#
use CGI;
my $qy = CGI->new; my $norm_search_terms; my $regex;
{
my $isamatch    = "[". ($qy->Vars->{search_scope} // 'b') ."]"; # default to Book search
my $skeys = $qy->Vars->{search_keys} // '';
   $skeys =~ s='==g; # ' mimic collection-maintenance file rename
my @search_keys = split( qr{[-\s,.:"]+}, $skeys ); # " preserve: [+#]
$norm_search_terms = join(' ',@search_keys);
$regex = gen_re_match_all_anyorder( @search_keys );
search_files( $isamatch, $regex );
}
print $qy->header;
print $qy->start_html(
      -title=>$norm_search_terms,
      -base=>'true', -target=>'_blank',  # links on this page will open in new client (browser) tab/window.
      );
print "$regex\n" if $showRegex;
# print $qy->Dump();
print $qy->h3("Found",($num_matches||"no"),"matches of '$norm_search_terms' among",$num_cands,"candidates",$qy->a({href=>"/"},"new search")), "\n";
for my $yr (reverse sort keys %dated_rslts) { # print "$yr:\n";
   print $qy->h3("&copy;".($yr || "<i>unknown</i>")), "\n";
   my @lis;
   for my $link_wo_type (sort @{$dated_rslts{$yr}}) {
      my ($fnm) = $link_wo_type =~ m=([^/]+)$=;
      my @out = ( $fnm );
      for my $type ( reverse sort @{$extra{$link_wo_type}} ) {  # reverse sort is a marginal first approximation of the 'order of [type] preference' described above
         push @out, $qy->a({href=>"$link_wo_type$type"},$type),"\n";
         }
      push @lis, $qy->li(join(' ',@out)),"\n";
      }
   print $qy->ol( @lis ), "\n";
   }
print $qy->end_html;
exit 0;
